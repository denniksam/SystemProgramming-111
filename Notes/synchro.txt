Объекты синхронизации

Специальные системные ресурсы, предназначенные для блокировки потоков (перевода
в состояние ожидания), а также восстановления их работы. Также эти объекты
называют "сигнальными", поскольку они сами подают сигналы об освобождении и
не требуют постоянного перезапроса состояния.

1. lock
Встроенный синтаксический элемент
Использует внутренние возможности ссылочных элементов (их критические секции)
Требует отдельного создания ссылочного объекта либо использование существующего

lock (locker) - блокировка объекта locker - только переводит его (locker-а)
{				 критическую секцию в сигнальное состояние, это никак не влияет
	....		 ни на доступность объекта locker (и его свойств), ни на его
}				 поведение (динамику, обработку событий)

Рекомендация - использовать в качестве locker-а константный объект.
Контр-пример:
String str = "Hello";	  | Синтаксически всё в норме, String - ссылочный тип
lock(str) {				  | НО! строки неизменны, поэтому оператор += создает
	str += " World";	  | новую строку
}						  | Конец блока - неявная команда разблокирования str
										 str
После работы блока:    [x"Hello"]   [o"Hello World"]
						| закрытая	 | открытая   критические секции (КС) объектов

Если второй поток также "смотрит" на str, то он стартует не после блока lock,
а после изменения str
+ появляется deadlock - ненужный объект (без ссылок, мусор) с закрытой КС
-----------------------------------------------------------------------------------------

2. Monitor
Встроенный класс Monitor (System.Threading) также "умеет" переводить объекты в
сигнальное состояние (блокировать) и также для этого нужен сторонний объект.

Monitor.Enter(monitor);  // Вход в монитор == блокирование объекта monitor
......
Monitor.Exit(monitor);   // Выход == разблокирование

Особенность с константными объектами - такая же
+ желательно гарантировать закрытие монитора в случае возникновения исключений 
в операционном блоке
try {
    Monitor.Enter(monitor);  // Вход в монитор == блокирование объекта monitor
	.....
}
finally {
    Monitor.Exit(monitor);  // Выход == разблокирование
}
-----------------------------------------------------------------------------------------

3. Mutex
Мьютексы - самостоятельные объекты, не требующие сторонних объектов для блокирования
Это также системные ресурсы, но более сложные, чем критические секции. Являются
объектами ядра системы и позволяют синхронизировать потоки из разных процессов.

private Mutex mutex = new();

    mutex.WaitOne();   // ожидание освобождение мьютекса и его блокировка в свою очередь
	........
    mutex.ReleaseMutex();

Особенность - try-finally

Объекты синхронизации предназначены для определенной группы потоков (задач) и 
используются для ограничения одновременного доступа к общим ресурсам
Если общих ресурсов несколько или работают разные группы задач, то объектов
синхронизации также нужно несколько.
-----------------------------------------------------------------------------------------

4. EventWaitHandle
"Ворота, турникет" пропускающий один поток (задачу). Открытием/закрытием можно
управлять. Можно создавать объект изначально закрытый

-----------------------------------------------------------------------------------------

5. Semaphore
Отличительная черта семафоров - пропуск сразу нескольких потоков. Возможность контроля
за кол-вом одновременно работающих задач/потоков
1-2-3-4-5 ---> (3) 
4-5 --> (0) -> 1-2-3
4-5 --> (1) -> 2-3 (1-закончилась, семафор показывает одно свободное место)
5 ----> (0) -> 4-2-3

-----------------------------------------------------------------------------------------

6. SemaphoreSlim - на самостоятельное изучение

Д.З. Использовать объект синхронизации SemaphoreSlim для организации последовательного
выполнения задач. Реализовать кнопку Стоп для этих задач (п. 6)
** Реализовать другие кнопки Стоп, прерывающие работу своей группы потоков/задач (пп.1-5)
