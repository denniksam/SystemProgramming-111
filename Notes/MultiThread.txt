Многопоточность, разделение задачи на потоки

Некоторые задачи позволяют решать свои части параллельно, не дожидаясь
решения других частей. Другими словами, части задачи могут переставлены
местами. Например, задача расчета суммы (среднего) слагаемых, получаемых из разных
источников - курсы валют разных бирж/банков, метеоданных из разных зондов и т.п.

среднее = (А+В+С) / 3   ==> A+B+C = B+A+C = C+A+B = ...

        запрос____А
старт < запрос_В    > cумма - среднее
        запрос__С

Задача: расчет суммы депозита со сложными процентами
каждый месяц депозит увеличивается на некоторый процент (например, на 10%)
задание - расчитать годовой эффект (за 12 месяцев)

100 + 10% = 110
110 + 10% = 121
.....

?? Можно ли переставлять данные??
 (100 + 10%) + 20%  =?= (100 + 20%) + 10%
 +10% -> x1.1,  +20% -> x1.2
 (100 x 1.1) x 1.2  =?= (100 x 1.2) x 1.1 да, это равенство. Значит "складывать"
   проценты можно в произвольном порядке

-------------------------------------------------------------------------
Главная проблема многопоточного решения - в разделении во времени операций
чтения данных и их записи
double val = sum;  чтение
sum = val;         запись
!! разница времени существует в любом случае, даже если запись минимизировать
sum *= percent
все равно сначала происходит расчет sum * percent, затем результат сохраняется
в sum, только длится это очень короткое время. ОДНАКО вероятность ошибки остается

Решение - синхронизация. Операционная система предоставляет объекты синхронизации
(сигнальные объекты) - критическая секция, мьютекс, семафор. На уровне .NET
каждый ссылочный тип данных имеет в своем составе критическую секцию и может
использоваться для синхронизации.
Следующая проблема - при неправильной синхронизации теряется параллельность и все
потоки суть выстраиваются в очередь и выполняются один за одним.

Решение - выделение транзакционных действий (требующих синхронизации) в 
минимальный блок, все остальное стараться из него исключить

Например, 
 [чтение - сложный расчет - запись]
  стараемся разделить сложный расчет на части, которые можно вычислять без чтения
 рез=часть рассчетов; [чтение - часть рассчетов - запись]

-----------------------------------------------------------------------------
Отмена потоков
Принципы отмены потоков были изменены при переходе от .Net Core 3
Внимательно смотрим на документации/форумы - к какой платформе они относятся

CancellationTokenSource cts - "пульт управления"
cts.Token - "управляемый элемент"

new Thread(plusPercent2).Start(cts.Token); - передаем в поток  токен, отменить который
можно только через cts
Причем все 12 потоков управляются одним "пультом"
поэтому команда cts?.Cancel(); переведет все (12) токенов в состояние "отмененный"

Отмена токена никак не влияет на поток, только на состояние токена.
Это состояние нужно периодически проверять (в теле потока) и принимать решение
по прекращению работы, обычно, в телах циклов

до .Net Core 3 поток отменялся иначе - в нем возникало исключение о прекращении
Из-за этого тела потоковых методов оформялись как try-catch
Для совместимости со старым подходом у токена есть возможность исключений
cancellationToken.ThrowIfCancellationRequested(); - это проверка отмены + выброс

Если в поток уже передаются данные, а нужно еще добавить и токен, то
создается комплексный тип данных, объединяющий предыдущие данные и токен

-----------------------------------------------------------------------------
Пул потоков (ThreadPool)   /   BackgroundWorker
Контейнер для потоков с управляемым количеством одновременно выполняемых потоков.
Особенности:
 - потоки работают в фоновом режиме (Background)
   = у них ниже приоритет (всего в ОС 3 приоритета: RealTime, Normal, Background.
      Обычный Thread - Normal)
   = потоки становятся зависимыми от основного потока и с его остановкой также
      останавливаются. !! Нужно обеспечивать контроллируемое закрытие приложений
      если необходимо дождаться окончания всех потоков.
 - количество одновременно выполняемых потоков ограниченно
   = более эффективно используется "железо" (не создавая лишних потоков, на
      которые будут переключения вместо параллельного выполнения)
   = распределяется нагрузка во времени - плавное тепловое/энергетическое распределение
